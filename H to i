def generate_xbm_data(ttf_path, char_list, forced_height, max_width, canvas_width, canvas_height,
                      threshold_value=128, padding_top=0, padding_bottom=0):
    """
    Generates XBM data for characters, ensuring proper padding and alignment.
    Handles special scaling rules for narrow characters like "I".
    """
    font_size = forced_height * 2
    font = ImageFont.truetype(ttf_path, font_size)
    all_xbm_data = {}

    # Define narrow characters
    narrow_characters = {"I", "l", "|"}

    for char in char_list:
        try:
            # Render the character
            (width, height), (offset_x, offset_y) = font.font.getsize(char)
            if width == 0 or height == 0:
                if char == " ":
                    width, height = max_width, forced_height
                else:
                    print(f"Warning: Character '{char}' has zero dimensions. Skipping.")
                    continue

            image = Image.new('L', (width, height), 0)
            draw = ImageDraw.Draw(image)
            draw.text((-offset_x, -offset_y), char, font=font, fill=255)

            # Special rule for narrow characters
            if char in narrow_characters:
                adjusted_aspect_ratio = 0.5  # Force a narrower aspect ratio
                scaled_width = min(int(forced_height * adjusted_aspect_ratio), max_width // 2)
            else:
                # Scale character to fit max dimensions
                aspect_ratio = width / height
                scaled_width = min(int(forced_height * aspect_ratio), max_width)

            # Resize character
            img_resized = image.resize((scaled_width, forced_height), Image.Resampling.LANCZOS)

            # Convert to binary array
            binary_array = (np.array(img_resized) > threshold_value).astype(np.uint8)

            # Create padded array
            padded_array = np.zeros((canvas_height, canvas_width), dtype=np.uint8)

            # Center horizontally
            horizontal_padding = (canvas_width - scaled_width) // 2
            padded_array[padding_top:padding_top + forced_height,
                         horizontal_padding:horizontal_padding + scaled_width] = binary_array

            # Convert each row to two bytes (16 bits)
            xbm_data = []
            for row in padded_array:
                byte1, byte2 = 0, 0
                for col in range(8):  # First byte (leftmost 8 bits)
                    if row[col]:
                        byte1 |= (1 << (7 - col))
                for col in range(8, 16):  # Second byte (rightmost 8 bits)
                    if col < canvas_width and row[col]:
                        byte2 |= (1 << (7 - (col - 8)))  # Adjust bit position correctly

                # Reverse bits for compatibility
                byte1 = reverse_bits(byte1)
                byte2 = reverse_bits(byte2)

                xbm_data.append((byte1, byte2))  # Append as a tuple of 2 bytes

            all_xbm_data[char] = xbm_data

        except Exception as e:
            print(f"Warning: Unable to process character '{char}'. Reason: {e}")

    return all_xbm_data
