def bitmap_to_xbm_fixed_height(bitmap, forced_height, max_width=7, threshold_value=40):
    # Convert the input bitmap to a numpy array
    bitmap_array = np.array(bitmap.buffer, dtype=np.uint8).reshape(bitmap.rows, bitmap.width)
    
    # Resize the bitmap to the forced height while maintaining aspect ratio for width
    img = Image.fromarray(bitmap_array)
    aspect_ratio = img.width / img.height
    new_width = min(int(forced_height * aspect_ratio), max_width)  # Calculate width with max constraint
    img_resized = img.resize((new_width, forced_height), Image.Resampling.LANCZOS)
    
    # Convert resized image to binary (black-and-white) array based on the threshold
    resized_array = np.array(img_resized)
    binary_array = (resized_array > threshold_value).astype(np.uint8)
    
    # Create the padded array with an 8-bit width, even if the actual character width is less
    padded_array = np.zeros((forced_height, 8), dtype=np.uint8)
    start_col = (8 - new_width) // 2  # Center-align character in 8-bit width
    
    # Place the binary character bitmap in the center of the 8-bit padded array
    padded_array[:, start_col:start_col + new_width] = binary_array[:, :new_width]
    
    # Initialize the XBM data list and convert each row to byte values
    xbm_data = []
    for row in padded_array:
        byte_value = 0
        for col in range(8):
            # Set bit if pixel is on (value > 0)
            if row[col] > 0:
                byte_value |= (1 << (7 - col))
        
        # Append the byte to XBM data for each row
        xbm_data.append(byte_value)

    # Return the XBM data, which is an 8-bit width, forced height format
    return xbm_data, 8, forced_height


# Example: Using forced height of 14, maximum width of 7 bits
xbm_data, width, height = bitmap_to_xbm_fixed_height(bitmap, forced_height=14, max_width=7)

# Output results for verification
print("XBM Data:", xbm_data)
print("Width:", width)    # Should be 8 bits
print("Height:", height)  # Forced height specified
